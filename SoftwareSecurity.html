<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Angle Privacy — Symmetric Fade</title>
<style>
  :root{
    /* одинаковая плавность туда и обратно */
    --dark: rgba(0,0,0,1);
    --fadeMs: 700ms;                     /* та же длительность для IN и OUT */
    --ease: cubic-bezier(.18,.88,.25,1); /* та же кривая для IN и OUT */
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background:#0b1020; color:#e7ecf3;
    display:grid; place-items:center; padding:28px;
    -webkit-tap-highlight-color: transparent;
  }
  .card{
    width:min(460px,92vw);
    border:1px solid #1f2942;
    background: linear-gradient(180deg,#141b33 0%, #11162a 100%);
    border-radius:22px; padding:26px 22px 28px;
    box-shadow: 0 20px 60px rgba(0,0,0,.45);
    text-align:center;
  }
  h1{margin:0 0 16px; font-size:22px; font-weight:800}
  .btn{
    -webkit-appearance:none; appearance:none; border:0; cursor:pointer;
    width:100%; padding:14px 18px; border-radius:16px;
    font-weight:800; letter-spacing:.4px; color:#fff;
    background: linear-gradient(90deg,#6f68ff,#8c4dff);
    box-shadow: 0 0 32px rgba(143,109,255,.35);
  }
  .btn:active{ transform: translateY(1px) }

  /* полностью чёрный слой — без текста/блюра */
  .overlay{
    position:fixed; inset:0; display:none; z-index:9999;
    background: rgba(0,0,0,0);
    pointer-events:auto; touch-action:none;
    will-change: background;
  }
  .overlay.visible{ display:block; }

  /* один и тот же «характер» анимации для IN и OUT */
  @keyframes fadeToDark { from { background: rgba(0,0,0,0); } to { background: var(--dark); } }
  @keyframes darkToClear{ from { background: var(--dark); }    to { background: rgba(0,0,0,0); } }

  .overlay.fade-in  { animation: fadeToDark var(--fadeMs) var(--ease) forwards; }
  .overlay.hold     { background: var(--dark); }
  .overlay.fade-out { animation: darkToClear var(--fadeMs) var(--ease) forwards; }
</style>
</head>
<body>
  <div class="card">
    <h1>Angle Privacy</h1>
    <button class="btn" id="activate">GET INSIGHTS</button>
  </div>

  <div class="overlay" id="overlay"></div>

<script>
  const overlay = document.getElementById('overlay');
  const btn = document.getElementById('activate');

  /* === Параметры ===
     THRESHOLD_DEG — ОДИН и тот же угол (симметрично) для входа/выхода.
     SMOOTH_ALPHA — то же сглаживание для обеих сторон.
  */
  const THRESHOLD_DEG = 24;   // как на затемнении — можно 20–28 под ощущение
  const SMOOTH_ALPHA  = 0.20; // одно и то же сглаживание IN/OUT
  const EPS           = 0.5;  // крошечный буфер от дрожи (почти незаметен)

  let activated = false;
  let usingSensors = false;

  // калибровка «прямого взгляда»
  let baselineGamma = 0;
  let needCalibrate = false;

  // сглаженный модуль Δугла (|gamma - baseline|)
  let gFiltered = 0;

  // состояние
  let isDark = false;

  btn.addEventListener('click', async () => {
    activated = true;
    needCalibrate = true;      // возьмём baseline сразу после клика
    await enableMotion();
  });

  /* === Анимации (симметричные) === */
  function beginDark(){
    // перезапуск IN
    overlay.className = 'overlay visible';
    void overlay.offsetWidth;
    overlay.classList.add('fade-in');

    overlay.addEventListener('animationend', function onIn(e){
      if (e.animationName !== 'fadeToDark') return;
      overlay.removeEventListener('animationend', onIn);
      overlay.classList.remove('fade-in');
      overlay.classList.add('hold');
      isDark = true;
    }, { once:true });
  }

  function endDark(){
    // перезапуск OUT — сразу, без задержек
    overlay.classList.remove('hold','fade-in','fade-out');
    overlay.classList.add('fade-out');

    overlay.addEventListener('animationend', function onOut(e){
      if (e.animationName !== 'darkToClear') return;
      overlay.removeEventListener('animationend', onOut);
      overlay.classList.remove('fade-out','visible');
      isDark = false;
    }, { once:true });
  }

  /* === Помощники === */
  const abs = Math.abs;
  const near = (a,b,tol)=> abs(a-b) <= tol;

  function deltaFromBaseline(rawGamma){
    const gAbs = abs(rawGamma ?? 0);
    return abs(gAbs - baselineGamma);
  }

  /* Фолбэк на системную смену ориентации (не обязателен) */
  if (window.matchMedia){
    const mql = matchMedia('(orientation: landscape)');
    mql.addEventListener?.('change', () => {
      if (!activated) return;
      if (mql.matches) { if(!isDark) beginDark(); }
      else { if(isDark) endDark(); }
    });
  }

  /* === Датчики ориентации — симметричная логика по одному порогу === */
  async function enableMotion(){
    if (usingSensors) return;
    try {
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        const res = await DeviceOrientationEvent.requestPermission();
        if (res !== 'granted') return;
      }
    } catch(e){}

    window.addEventListener('deviceorientation', (e) => {
      if (!activated) return;

      const rawGamma = e.gamma;

      // первичная калибровка позы «прямо»
      if (needCalibrate){
        baselineGamma = abs(rawGamma ?? 0);
        needCalibrate = false;
        gFiltered = 0;
      }

      const deltaRaw = deltaFromBaseline(rawGamma);
      // одно и то же сглаживание для IN и OUT
      gFiltered = SMOOTH_ALPHA * deltaRaw + (1 - SMOOTH_ALPHA) * gFiltered;

      // симметричный порог: если пересекли вверх — темним, вниз — светлим
      if (!isDark && gFiltered >= THRESHOLD_DEG + EPS){
        beginDark();
      } else if (isDark && gFiltered <= THRESHOLD_DEG - EPS){
        endDark();
      }
    }, { passive:true });

    usingSensors = true;
  }
</script>
</body>
</html>
