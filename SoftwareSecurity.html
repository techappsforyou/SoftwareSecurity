<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Angle Privacy — Snap Back to Bright</title>
<style>
  :root{
    /* можно подстроить эти параметры под ролик/ощущение */
    --dark: rgba(0,0,0,1);       /* ПОЛНОЕ затемнение */
    --fadeInMs: 700ms;           /* плавный, “масляный” вход */
    --fadeOutMs: 160ms;          /* обычный выход */
    --fadeOutFastMs: 110ms;      /* быстрый выход при возврате в “те же градусы” */
    --easeIn: cubic-bezier(.18,.88,.25,1);
    --easeOut: cubic-bezier(.3,.1,.3,1);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background:#0b1020; color:#e7ecf3;
    display:grid; place-items:center; padding:28px;
    -webkit-tap-highlight-color: transparent;
  }
  .card{
    width:min(460px,92vw);
    border:1px solid #1f2942;
    background: linear-gradient(180deg,#141b33 0%, #11162a 100%);
    border-radius:22px; padding:26px 22px 28px;
    box-shadow: 0 20px 60px rgba(0,0,0,.45);
    text-align:center;
  }
  h1{margin:0 0 16px; font-size:22px; font-weight:800}
  .btn{
    -webkit-appearance:none; appearance:none; border:0; cursor:pointer;
    width:100%; padding:14px 18px; border-radius:16px;
    font-weight:800; letter-spacing:.4px; color:#fff;
    background: linear-gradient(90deg,#6f68ff,#8c4dff);
    box-shadow: 0 0 32px rgba(143,109,255,.35);
  }
  .btn:active{ transform: translateY(1px) }

  /* Чистый чёрный оверлей — без текста/вспышек/блюра, чтобы не просвечивало */
  .overlay{
    position:fixed; inset:0; display:none; z-index:9999;
    background: rgba(0,0,0,0);
    pointer-events:auto; touch-action:none;
    will-change: background;
  }
  .overlay.visible{ display:block; }

  @keyframes fadeToDark { from { background: rgba(0,0,0,0); } to { background: var(--dark); } }
  @keyframes darkToClear{ from { background: var(--dark); }    to { background: rgba(0,0,0,0); } }

  .overlay.fade-in        { animation: fadeToDark var(--fadeInMs) var(--easeIn) forwards; }
  .overlay.hold           { background: var(--dark); }
  .overlay.fade-out       { animation: darkToClear var(--fadeOutMs) var(--easeOut) forwards; }
  .overlay.fade-out-fast  { animation: darkToClear var(--fadeOutFastMs) linear forwards; }
</style>
</head>
<body>
  <div class="card">
    <h1>Angle Privacy</h1>
    <button class="btn" id="activate">GET INSIGHTS</button>
  </div>

  <div class="overlay" id="overlay"></div>

<script>
  const overlay = document.getElementById('overlay');
  const btn = document.getElementById('activate');

  /* === Настройки поведения ===
     ENTER_DEG: при каком Δугле от “прямого взгляда” начинать затемнять.
     RETURN_TOL: окно “те же градусы” вокруг базовой позы — быстрый выход.
     EXIT_DEG: обычный порог выхода, если не попали прямо в RETURN_TOL.
  */
  const ENTER_DEG   = 24;  // старт затемнения раньше (можно 20–28)
  const RETURN_TOL  = 8;   // “вернулся в те же градусы” → быстрый выход
  const EXIT_DEG    = 14;  // обычный ранний выход (гистерезис)
  const SMOOTH_ALPHA = 0.22; // сглаживание датчика (0..1) — больше = быстрее

  // минимальная защита от дрожи, чтобы не мигало при «границе»
  const MIN_HOLD_MS = 80;

  let activated = false;
  let usingSensors = false;

  // калибровка “прямого взгляда”
  let baselineGamma = 0;     // базовый |gamma| при нажатии кнопки
  let needCalibrate = false; // взять baseline с первого event после активации

  // сглаженное “насколько мы сбоку” относительно базового
  let gFiltered = 0;

  // состояние затемнения
  let isDark = false;
  let holdUntil = 0;
  let hideTimer = null;

  btn.addEventListener('click', async () => {
    activated = true;
    needCalibrate = true;     // возьмём базовый угол на первом событии
    await enableMotion();
  });

  /* === Логика анимаций === */
  function beginDark(){
    clearTimeout(hideTimer);
    // перезапуск входной анимации
    overlay.className = 'overlay visible';
    void overlay.offsetWidth;
    overlay.classList.add('fade-in');
    isDark = true;
    holdUntil = Date.now() + MIN_HOLD_MS;

    overlay.addEventListener('animationend', function onIn(e){
      if (e.animationName !== 'fadeToDark') return;
      overlay.removeEventListener('animationend', onIn);
      overlay.classList.remove('fade-in');
      overlay.classList.add('hold');
    }, { once:true });
  }

  function endDark(fast=false){
    const left = holdUntil - Date.now();
    if (left > 0){
      clearTimeout(hideTimer);
      hideTimer = setTimeout(() => endDark(fast), left + 8);
      return;
    }
    overlay.classList.remove('hold','fade-in','fade-out','fade-out-fast');
    overlay.classList.add(fast ? 'fade-out-fast' : 'fade-out');
    overlay.addEventListener('animationend', function onOut(e){
      if (e.animationName !== 'darkToClear') return;
      overlay.removeEventListener('animationend', onOut);
      overlay.classList.remove('fade-out','fade-out-fast','visible');
      isDark = false;
    }, { once:true });
  }

  /* === Помощники === */
  const abs = Math.abs;

  function deltaFromBaseline(rawGamma){
    const gAbs = abs(rawGamma ?? 0);
    return abs(gAbs - baselineGamma);
  }

  function inReturnZone(deltaRaw){
    // «почти те же градусы», без сглаживания — чтобы выход был мгновенный
    return deltaRaw <= RETURN_TOL;
  }

  /* === Фолбэк на системную ориентацию (если вдруг датчиков нет) === */
  if (window.matchMedia){
    const mql = matchMedia('(orientation: landscape)');
    mql.addEventListener?.('change', () => {
      if (!activated) return;
      if (mql.matches) beginDark(); else endDark(true);
    });
  }

  /* === Датчики ориентации === */
  async function enableMotion(){
    if (usingSensors) return;
    try {
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        const res = await DeviceOrientationEvent.requestPermission();
        if (res !== 'granted') return;
      }
    } catch(e){}

    window.addEventListener('deviceorientation', (e) => {
      if (!activated) return;

      const rawGamma = e.gamma;
      const deltaRaw = deltaFromBaseline(rawGamma);

      // первая калибровка под твоё «прямо»
      if (needCalibrate){
        baselineGamma = abs(rawGamma ?? 0);
        needCalibrate = false;
        gFiltered = 0;
      }

      // плавное сглаживание для входа/выхода по порогам
      gFiltered = SMOOTH_ALPHA * deltaRaw + (1 - SMOOTH_ALPHA) * gFiltered;

      // 1) Приоритет: вернулся “в те же градусы” → быстрый выход
      if (isDark && inReturnZone(deltaRaw)){
        endDark(true); // очень быстрый выход
        return;
      }

      // 2) Обычная логика с гистерезисом и мягкими порогами
      if (!isDark){
        if (gFiltered >= ENTER_DEG) beginDark();
      }else{
        holdUntil = Date.now() + MIN_HOLD_MS; // защита от дрожи
        if (gFiltered <= EXIT_DEG) endDark(false);
      }
    }, { passive:true });

    usingSensors = true;
  }
</script>
</body>
</html>
