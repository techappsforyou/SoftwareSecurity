<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Angle Privacy — Stable & Smooth</title>
<style>
  :root{
    /* Тонкая настройка под видео */
    --fadeMs: 700ms;                         /* одинаковая плавность туда/обратно */
    --ease: cubic-bezier(.18,.88,.25,1);     /* характер кривой */
    --mask: rgba(0,0,0,1);                   /* полная темнота */
  }

  *{ box-sizing:border-box }
  html,body{ height:100%; margin:0 }
  body{
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background:#0b1020; color:#e7ecf3;
    display:grid; place-items:center; padding:28px;
    -webkit-tap-highlight-color: transparent;
  }

  .card{
    width:min(460px,92vw);
    border:1px solid #1f2942;
    background: linear-gradient(180deg,#141b33 0%, #11162a 100%);
    border-radius:22px; padding:26px 22px 28px;
    box-shadow: 0 20px 60px rgba(0,0,0,.45);
    text-align:center;
  }
  h1{ margin:0 0 16px; font-size:22px; font-weight:800 }
  .btn{
    -webkit-appearance:none; appearance:none; border:0; cursor:pointer;
    width:100%; padding:14px 18px; border-radius:16px; font-weight:800; letter-spacing:.4px;
    color:#fff; background: linear-gradient(90deg,#6f68ff,#8c4dff);
    box-shadow: 0 0 32px rgba(143,109,255,.35);
  }
  .btn:active{ transform: translateY(1px) }

  /* Оверлей: без display:none, только opacity/visibility → никаких рывков */
  .overlay{
    position:fixed; inset:0; z-index:9999;
    background: var(--mask);
    opacity:0; visibility:hidden;
    pointer-events:none;                /* клики проходят когда светло */
    transition: opacity var(--fadeMs) var(--ease), visibility 0s linear var(--fadeMs);
    will-change: opacity;
  }
  .overlay.on{
    opacity:1; visibility:visible;
    pointer-events:auto;
    transition: opacity var(--fadeMs) var(--ease), visibility 0s;
  }
</style>
</head>
<body>
  <div class="card">
    <h1>Angle Privacy</h1>
    <button class="btn" id="activate">GET INSIGHTS</button>
  </div>

  <div class="overlay" id="overlay" aria-hidden="true"></div>

<script>
  const overlay = document.getElementById('overlay');
  const btn = document.getElementById('activate');

  /* ===== Параметры поведения =====
     THRESHOLD_DEG — один порог для входа/выхода (симметрично).
     HYST_DEG      — крошечный гистерезис, чтобы не дрожало на границе.
     CALIB_MS      — короткая калибровка (усреднение) после клика.
  */
  const THRESHOLD_DEG = 24;   // начни темнить около 24°
  const HYST_DEG      = 2;    // на 2° раньше возвращаем яркость (защита от дрожи)
  const CALIB_MS      = 300;  // 300 мс собираем базу «как держишь сейчас»

  let activated = false;
  let sensorsOn = false;

  // База «прямо» (усреднённая по первым событиям)
  let baseG = 0, baseB = 0;
  let calibStart = 0, calibCount = 0;
  let calibrating = false;

  // Состояние слоя и защита от повторных операций
  let isDark = false;

  btn.addEventListener('click', async () => {
    activated = true;
    startCalibration();
    await ensureSensors();
  });

  function startCalibration(){
    // Сбрасываем базу и в течение CALIB_MS усредняем beta/gamma в абсолютных значениях
    baseG = 0; baseB = 0; calibCount = 0;
    calibrating = true;
    calibStart = performance.now();
  }

  function maybeFinishCalibration(){
    if (!calibrating) return;
    if (performance.now() - calibStart >= CALIB_MS && calibCount > 0){
      baseG = baseG / calibCount;
      baseB = baseB / calibCount;
      calibrating = false;
    }
  }

  function setOverlay(on){
    if (on && !isDark){
      isDark = true;
      overlay.classList.add('on');
    } else if (!on && isDark){
      isDark = false;
      overlay.classList.remove('on');
    }
  }

  function deltaFromBase(beta, gamma){
    const g = Math.abs(gamma ?? 0);
    const b = Math.abs(beta  ?? 0);
    const dG = Math.abs(g - baseG);
    const dB = Math.abs(b - baseB);
    return Math.max(dG, dB); // берём «наибольший уход» — боковой или вперёд/назад
  }

  async function ensureSensors(){
    if (sensorsOn) return;
    try {
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        const res = await DeviceOrientationEvent.requestPermission();
        if (res !== 'granted') return;
      }
    } catch(e){/* noop */}

    window.addEventListener('deviceorientation', (e) => {
      if (!activated) return;

      const { beta, gamma } = e;
      if (beta == null && gamma == null) return;

      // Во время калибровки аккумулируем «как держишь прямо»
      if (calibrating){
        baseG += Math.abs(gamma ?? 0);
        baseB += Math.abs(beta  ?? 0);
        calibCount++;
        maybeFinishCalibration();
        return; // пока база собирается — не дёргаем слой
      }

      const delta = deltaFromBase(beta, gamma);

      // Симметричная логика + маленький гистерезис
      if (!isDark && delta >= (THRESHOLD_DEG)) {
        setOverlay(true);
      } else if (isDark && delta <= (THRESHOLD_DEG - HYST_DEG)) {
        setOverlay(false);
      }
    }, { passive:true });

    sensorsOn = true;
  }
</script>
</body>
</html>
