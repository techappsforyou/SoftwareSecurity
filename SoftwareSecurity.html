<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Angle Privacy — Smooth In & Out</title>
<style>
  :root{
    /* Параметры плавности */
    --dark: rgba(0,0,0,1);          /* Полное затемнение */
    --fadeInMs: 700ms;              /* Вход в темноту (плавный) */
    --fadeOutMs: 700ms;             /* Обычный выход — такой же плавный */
    --fadeOutFastMs: 520ms;         /* Быстрый (но тоже плавный) выход при «те же градусы» */
    --easeInOut: cubic-bezier(.18,.88,.25,1); /* та же кривая для обоих направлений */
  }

  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background:#0b1020; color:#e7ecf3;
    display:grid; place-items:center; padding:28px;
    -webkit-tap-highlight-color: transparent;
  }

  .card{
    width:min(460px,92vw);
    border:1px solid #1f2942;
    background: linear-gradient(180deg,#141b33 0%, #11162a 100%);
    border-radius:22px; padding:26px 22px 28px;
    box-shadow: 0 20px 60px rgba(0,0,0,.45);
    text-align:center;
  }
  h1{margin:0 0 16px; font-size:22px; font-weight:800}
  .btn{
    -webkit-appearance:none; appearance:none; border:0; cursor:pointer;
    width:100%; padding:14px 18px; border-radius:16px;
    font-weight:800; letter-spacing:.4px; color:#fff;
    background: linear-gradient(90deg,#6f68ff,#8c4dff);
    box-shadow: 0 0 32px rgba(143,109,255,.35);
  }
  .btn:active{ transform: translateY(1px) }

  /* Полностью чёрный оверлей — без текста/блюра, чтобы не «просвечивало» */
  .overlay{
    position:fixed; inset:0; display:none; z-index:9999;
    background: rgba(0,0,0,0);
    pointer-events:auto; touch-action:none;
    will-change: background;
  }
  .overlay.visible{ display:block; }

  /* Ключи: используем одну и ту же кривую для «туда и обратно» */
  @keyframes fadeToDark { from { background: rgba(0,0,0,0); } to { background: var(--dark); } }
  @keyframes darkToClear{ from { background: var(--dark); }    to { background: rgba(0,0,0,0); } }

  .overlay.fade-in        { animation: fadeToDark var(--fadeInMs) var(--easeInOut) forwards; }
  .overlay.hold           { background: var(--dark); }
  .overlay.fade-out       { animation: darkToClear var(--fadeOutMs) var(--easeInOut) forwards; }
  .overlay.fade-out-fast  { animation: darkToClear var(--fadeOutFastMs) var(--easeInOut) forwards; }
</style>
</head>
<body>
  <div class="card">
    <h1>Angle Privacy</h1>
    <button class="btn" id="activate">GET INSIGHTS</button>
  </div>

  <div class="overlay" id="overlay"></div>

<script>
  const overlay = document.getElementById('overlay');
  const btn = document.getElementById('activate');

  /* === Пороговая логика ===
     ENTER_DEG — когда начинаем темнить (относительно калибровки).
     RETURN_TOL — «те же градусы» → ранний, но ПЛАВНЫЙ выход.
     EXIT_DEG — обычный порог выхода, если не попали в RETURN_TOL.
  */
  const ENTER_DEG    = 24;   // ранний вход в темноту
  const RETURN_TOL   = 8;    // зона «вернулся в те же градусы»
  const EXIT_DEG     = 14;   // обычный ранний выход
  const SMOOTH_ALPHA = 0.20; // сглаживание датчика (0..1)
  const MIN_HOLD_MS  = 80;   // анти-дребезг, чтобы не мигало на границе

  let activated = false;
  let usingSensors = false;

  // калибровка «прямого взгляда»
  let baselineGamma = 0;
  let needCalibrate = false;

  // сглаженный модуль Δугла (|gamma - baseline|)
  let gFiltered = 0;

  // состояние затемнения
  let isDark = false;
  let holdUntil = 0;
  let hideTimer = null;

  btn.addEventListener('click', async () => {
    activated = true;
    needCalibrate = true;            // возьмём baseline с первого события
    await enableMotion();
  });

  /* === Анимации === */
  function beginDark(){
    clearTimeout(hideTimer);
    overlay.className = 'overlay visible'; // сброс
    void overlay.offsetWidth;              // reflow для перезапуска
    overlay.classList.add('fade-in');
    isDark = true;
    holdUntil = Date.now() + MIN_HOLD_MS;

    overlay.addEventListener('animationend', function onIn(e){
      if (e.animationName !== 'fadeToDark') return;
      overlay.removeEventListener('animationend', onIn);
      overlay.classList.remove('fade-in');
      overlay.classList.add('hold');
    }, { once:true });
  }

  function endDark(fast=false){
    const left = holdUntil - Date.now();
    if (left > 0){
      clearTimeout(hideTimer);
      hideTimer = setTimeout(() => endDark(fast), left + 8);
      return;
    }
    overlay.classList.remove('hold','fade-in','fade-out','fade-out-fast');
    overlay.classList.add(fast ? 'fade-out-fast' : 'fade-out');
    overlay.addEventListener('animationend', function onOut(e){
      if (e.animationName !== 'darkToClear') return;
      overlay.removeEventListener('animationend', onOut);
      overlay.classList.remove('fade-out','fade-out-fast','visible');
      isDark = false;
    }, { once:true });
  }

  /* === Помощники === */
  const abs = Math.abs;
  function deltaFromBaseline(rawGamma){
    const gAbs = abs(rawGamma ?? 0);
    return abs(gAbs - baselineGamma);
  }
  function inReturnZone(deltaRaw){ return deltaRaw <= RETURN_TOL; }

  /* Фолбэк на системную смену ориентации — не обязателен, но пусть будет */
  if (window.matchMedia){
    const mql = matchMedia('(orientation: landscape)');
    mql.addEventListener?.('change', () => {
      if (!activated) return;
      if (mql.matches) beginDark(); else endDark(true);
    });
  }

  /* === Датчики ориентации === */
  async function enableMotion(){
    if (usingSensors) return;
    try {
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        const res = await DeviceOrientationEvent.requestPermission();
        if (res !== 'granted') return;
      }
    } catch(e){}

    window.addEventListener('deviceorientation', (e) => {
      if (!activated) return;

      const rawGamma = e.gamma;
      const deltaRaw = deltaFromBaseline(rawGamma);

      // первичная калибровка «прямо»
      if (needCalibrate){
        baselineGamma = abs(rawGamma ?? 0);
        needCalibrate = false;
        gFiltered = 0;
      }

      // сглаживание, чтобы анимации вход/выход были спокойные
      gFiltered = SMOOTH_ALPHA * deltaRaw + (1 - SMOOTH_ALPHA) * gFiltered;

      // приоритетный ранний выход, если вернулся почти в ту же позу
      if (isDark && inReturnZone(deltaRaw)){
        endDark(true); // быстрый, но ПЛАВНЫЙ выход (520ms, та же кривая)
        return;
      }

      if (!isDark){
        if (gFiltered >= ENTER_DEG) beginDark();
      } else {
        holdUntil = Date.now() + MIN_HOLD_MS; // анти-дребезг
        if (gFiltered <= EXIT_DEG) endDark(false); // обычный плавный выход (700ms)
      }
    }, { passive:true });

    usingSensors = true;
  }
</script>
</body>
</html>
